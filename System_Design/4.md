# Normalisation

- Putting data in multiple table to reduce redundancy

# Denormalisation

- Putting data in one table to increase performance

## Benefits of Denormalisation

- Faster reads
- Simpler queries
- Management Convenience
- High availability
- Reduces the network calls
- Reduces the number of joins

## Drawbacks of Denormalisation

- Slower writes
- Redundant data- wastage of space and money
- Increase Complexity
- Data inconsistency
- Difficult to maintain

# Indexing

- Indexing is a way to optimize the performance of a database by minimizing the number of disk accesses required when a query is processed. It is a data structure technique which is used to quickly locate and access the data in a database.

```mermaid
graph LR;
subgraph Students
A[id name age netWorth]
B[1 Ram 12 8000]
C[2 Radha 14 3400]
D[3 Seeta 14 300]
E[4 Ramu 14 3000]
end
subgraph Networth
X[netWorth]
Y[300]
Z[3000]
WW[3400]
W[8000]
end
D-->Y
B-->W
C-->WW
E-->Z
subgraph Indexing
XRT[Now it is optimised <br>here a separate memory<br>is assigned]
end
subgraph DataStructure
XRTR[B-trees structure <br>used to store indexing]
end
```

- Used in Read Intensive Application

# Synchronous Communication

```mermaid
graph LR;
A("<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/amazon.png'; width='80' />")-->B("<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/cart.jpeg'; width='80' />")-->C[Synchronous<br>Item in stock<br> or not during order<br>wait or block to check<br>highly consistent]
D("<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/amazon.png''; width='80' />")-->E("<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/pay.jpeg'; width='80' />")-->F[Synchronous<br>Payment<br>highly consistent]
G("<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/amazon.png''; width='80' />")-->H("<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/notification.png'; width='80' />")-->I[ASynchronous<br>no problem if<br>we receive notification<br> with delay]
```

## Where Asynchronous Communication is necessary

- Computation takes a lot of time
- Scalability of application
- Avoid Cascading Failures

# Message Based Communication

- Client send requests in the form of messages to the server and server send response in the form of messages to the client
- so it is asynchronous communication

## Producer

## Consumer

## Agent

## P2P Model

- Peer to Peer Model
- Email are not sent immediately
- Email are stored in the queue and then sent
- Email are sent in the form of messages
- Email are sent asynchronously

## Public Subscriber Model

- Email are sent to all the subscribers
- Email are sent in the form of messages
- Email are sent asynchronously

## Examples

- Kafka
- RabbitMQ
- ActiveMQ
- Amazon SQS

# Kafka 

- Zomato :

  - Live loaction of delivery partner we see
  - life feed we are getting each second of driver location
  - this can not be done using data base because if we are calling database each second our database will go down
  - throughput of database is low
  - throughput of kafka is high
- Kafka has high throughput
- but Kafka's storage is temporary and very low
- DB: throughput low ,storage high, we can query the data

```mermaid
graph LR;
A["<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/zomato.png''; width='80' />"<br>Zomato<br>producing 1m data per seconds<br><br>Producer]
B["<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/kafka.png''; width='80' />"<br>Kafka<br>Consuming the datas]
A-->B--Bulk insert after<br> a fixed time-->C["<img src='https://raw.githubusercontent.com/shubham21155102/Archieve/main/System_Design/psql.png''; width='80' />"<br>Kafka<br>Consuming the datas]
subgraph Datas
B-->Speed
B-->Distance
B-->Time
X[1 million datas]
end
```
